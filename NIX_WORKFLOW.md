# Reproducible R Package Development with Nix and rix

**Complete workflow for developing R packages with Nix, ensuring reproducibility and consistency between local development and GitHub Actions CI/CD**

---

## Table of Contents

1. [Overview](#overview)
2. [The Three-File Strategy](#the-three-file-strategy)
3. [How Content-Addressable Hashing Ensures Correctness](#how-content-addressable-hashing-ensures-correctness)
4. [The Complete 9-Step Workflow](#the-complete-9-step-workflow)
5. [Generating Nix Files with rix](#generating-nix-files-with-rix)
6. [GitHub Actions CI/CD Setup](#github-actions-cicd-setup)
7. [Cachix Setup](#cachix-setup)
8. [Troubleshooting](#troubleshooting)
9. [Quick Reference](#quick-reference)
10. [Known Limitations](#known-limitations)

---

## Overview

### Goals

1. **Reproducibility**: Identical builds locally and in CI
2. **Consistency**: Same dependencies across all environments
3. **Simplicity**: Transparent workflow using R code
4. **Efficiency**: Fast CI via binary caches (no rebuilding)

### Key Technologies

- **Nix**: Reproducible package manager
- **rix**: R package for generating Nix expressions
- **Cachix**: Binary cache for pre-built packages
- **GitHub Actions**: CI/CD platform

---

## The Three-File Strategy

We use THREE nix files, each with a specific purpose:

### 1. `package.nix` - Package Derivation (Runtime Only)

**Purpose**: Build your R package as a proper Nix derivation

**Contains**:
- Runtime dependencies (DESCRIPTION `Imports`)
- Build dependencies (vignette builders: knitr, rmarkdown, quarto)
- Package metadata

**Used by**:
- Local package builds: `nix-build package.nix`
- Cachix push script
- GitHub Actions (for caching the package derivation)

**Example**:
```nix
# package.nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.rPackages.buildRPackage {
  name = "yourpackage";
  src = ./.;

  propagatedBuildInputs = with pkgs.rPackages; [
    dplyr
    ggplot2
  ];

  nativeBuildInputs = with pkgs.rPackages; [
    knitr
    rmarkdown
  ];
}
```

### 2. `default-ci.nix` - CI/Dev Environment (All Tools)

**Purpose**: Create development environment with ALL dependencies + development tools

**Contains**:
- All R packages (runtime + suggested + dev tools)
- System packages (git, gh, quarto, pandoc)
- Shell configuration

**Used by**:
- Local development: `nix-shell default-ci.nix`
- GitHub Actions for running tests, checks, pkgdown
- Ensuring CI matches local environment

**Generated by**: `rix::rix()` function

### 3. `default.nix` - Local Dev (Symlink)

**Purpose**: Ensure local development uses same environment as CI

**Contents**: Symlink to `default-ci.nix`

**Created by**: `ln -s default-ci.nix default.nix`

**Why symlink?**: Guarantees local == CI, reduces maintenance

---

## How Content-Addressable Hashing Ensures Correctness

### The Problem

**Question**: How does GitHub Actions know the cached package matches the code being tested?

### The Solution

**Nix uses content-addressable hashing**: The store path includes a hash of:
- **Source code** (every file in your package)
- **Dependencies** (exact versions)
- **Build instructions** (from package.nix)

### The Magic

```
Same code + Same deps + Same build = Same hash = Same derivation path
Different code ‚Üí Different hash ‚Üí Different path ‚Üí Cache miss ‚Üí Rebuild
```

### Example

```bash
# Local: You build package with version 1.0.0
nix-build package.nix
# Output: /nix/store/abc123xyz-yourpackage-1.0.0

# You push this derivation to cachix
nix-store -qR result | cachix push johngavin

# You push code to GitHub
git push

# GitHub Actions: Checks out YOUR code, builds package.nix
# Nix computes hash from the checked-out source
# Hash = abc123xyz (because source is identical)
# Checks cachix: "Do you have abc123xyz?"
# YES! Download it (instant, no rebuild)
```

**If you forgot to push to cachix or changed code without rebuilding:**

```bash
# CI checks out DIFFERENT code (e.g., version 1.0.1)
# Nix computes NEW hash: def456uvw
# Checks cachix: "Do you have def456uvw?"
# NO! Must rebuild from source
# Pushes new derivation to cachix
```

**Key insight**: You cannot accidentally use the wrong version. The hash won't match.

---

## The Complete 9-Step Workflow

### Updated Workflow (December 2025)

**CRITICAL**: Step 5 (push to cachix) is now **MANDATORY** before pushing to GitHub.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Create GitHub Issue (#123)                                 ‚îÇ
‚îÇ 2. Create dev branch (usethis::pr_init())                     ‚îÇ
‚îÇ 3. Make changes locally                                       ‚îÇ
‚îÇ 4. Run all checks (devtools::check(), etc.)                   ‚îÇ
‚îÇ 5. ‚ö†Ô∏è MANDATORY: Push to johngavin cachix ‚ö†Ô∏è                   ‚îÇ
‚îÇ    ‚îî‚îÄ‚Üí ../push_to_cachix.sh                                   ‚îÇ
‚îÇ 6. Push to GitHub (usethis::pr_push())                        ‚îÇ
‚îÇ 7. Wait for GitHub Actions (pulls from cachix - fast!)        ‚îÇ
‚îÇ 8. Merge PR (usethis::pr_merge_main())                        ‚îÇ
‚îÇ 9. Log everything (R/setup/fix_issue_123.R)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Step-by-Step Example

#### Step 1: Create GitHub Issue

```r
# Using gh package
gh::gh("POST /repos/{owner}/{repo}/issues",
  owner = "JohnGavin",
  repo = "randomwalk",
  title = "Add new feature X",
  body = "Description of feature X"
)
# Note issue number, e.g., #123
```

#### Step 2: Create Development Branch

```r
# Using usethis
usethis::pr_init("fix-issue-123-feature-x")
```

#### Step 3: Make Changes

```r
# Edit R/your_function.R
# Edit tests/testthat/test-your_function.R

# Commit locally
gert::git_add(c("R/your_function.R", "tests/testthat/test-your_function.R"))
gert::git_commit("Add feature X for #123")
```

#### Step 4: Run All Checks Locally

```r
# Reload package
devtools::load_all()

# Run tests
devtools::test()

# R CMD check
devtools::check()

# Build pkgdown
pkgdown::build_site()

# If you changed DESCRIPTION, regenerate nix files
source("R/setup/generate_nix_files.R")
generate_all_nix_files()
```

#### Step 5: üö® MANDATORY - Push to Cachix üö®

```bash
# From project directory (e.g., random_walk/)
../push_to_cachix.sh

# This script:
# 1. Detects package name from DESCRIPTION
# 2. Builds package.nix derivation
# 3. Pushes to johngavin cachix
# 4. Reports success
```

**Why this is mandatory**:
- ‚úÖ CI pulls from johngavin cachix (instant, no rebuild)
- ‚úÖ Consistent derivations between local and CI
- ‚úÖ Saves GitHub Actions minutes
- ‚úÖ Prevents "works locally but fails in CI"

#### Step 6: Push to GitHub

```r
# Push branch and create PR
usethis::pr_push()

# This:
# - Pushes branch to GitHub
# - Creates Pull Request
# - Links to issue #123
```

#### Step 7: Wait for GitHub Actions

All workflows must pass ‚úÖ:
- Build & Cache Package
- R CMD check
- Run Tests
- Build pkgdown site
- Verify nix files

**GitHub Actions will**:
1. Check out your code
2. Build package.nix
3. Compute hash (matches what you pushed!)
4. Pull from johngavin cachix (instant!)
5. Run tests in nix environment

#### Step 8: Merge PR

```r
# After all checks pass
usethis::pr_merge_main()
usethis::pr_finish()

# This:
# - Merges PR to main
# - Closes issue #123
# - Deletes dev branch
# - Switches back to main
```

#### Step 9: Log Everything

Already done! Your commands are in `R/setup/fix_issue_123.R`

---

## Generating Nix Files with rix

### Automated Generation from DESCRIPTION

All nix files can be generated from your `DESCRIPTION` file using rix.

### Using the Helper Script

```r
# From your package root directory
source("R/setup/generate_nix_files.R")

# Generate all files (package.nix, default-ci.nix, default.nix)
generate_all_nix_files()

# Generate with verification (checks syntax)
generate_all_nix_files(verify = TRUE)

# Use different nixpkgs revision
generate_all_nix_files(nixpkgs_rev = "YOUR_GIT_HASH")

# Update after modifying DESCRIPTION
update_nix_files()
```

### What Gets Generated

**From DESCRIPTION `Imports`** ‚Üí `package.nix` `propagatedBuildInputs`

**From DESCRIPTION `Suggests` (vignette builders)** ‚Üí `package.nix` `nativeBuildInputs`

**From DESCRIPTION all deps + dev tools** ‚Üí `default-ci.nix` R packages

### Example

```r
# DESCRIPTION
Package: randomwalk
Imports:
    logger,
    ggplot2,
    crew
Suggests:
    testthat,
    knitr,
    rmarkdown,
    pkgdown
```

**Generates**:

```nix
# package.nix
propagatedBuildInputs = [ logger ggplot2 crew ];
nativeBuildInputs = [ knitr rmarkdown ];

# default-ci.nix (via rix)
rpkgs = [ logger ggplot2 crew testthat knitr rmarkdown pkgdown
          devtools usethis gert gh rcmdcheck roxygen2 ];
```

---

## GitHub Actions CI/CD Setup

### Workflow File Location

`.github/workflows/nix-ci.yml`

### Jobs

1. **build-and-cache-package**: Build package.nix, push to johngavin cachix
2. **r-cmd-check**: Run R CMD check in nix environment
3. **test**: Run testthat tests
4. **pkgdown**: Build and deploy pkgdown site
5. **check-nix-generation**: Verify nix files are up to date
6. **ci-success**: Summary job

### Key Features

**Two-cache strategy**:
```yaml
- uses: cachix/cachix-action@v14
  with:
    name: rstats-on-nix  # All R packages

- uses: cachix/cachix-action@v14
  with:
    name: johngavin       # Your package
    authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
```

**Build package derivation**:
```yaml
- name: Build package derivation
  run: |
    nix-build package.nix
    nix-store -qR result | cachix push johngavin
```

**Run checks in nix environment**:
```yaml
- name: Run R CMD check
  run: |
    nix-shell default-ci.nix --run "
      Rscript -e 'rcmdcheck::rcmdcheck(...)'
    "
```

### Setup Requirements

1. **GitHub Secrets**: Add `CACHIX_AUTH_TOKEN`
2. **GitHub Pages**: Enable in repo settings (Settings ‚Üí Pages ‚Üí Source: GitHub Actions)
3. **Permissions**: Workflow has `contents: write`, `pages: write`

---

## Cachix Setup

### What is Cachix?

Binary cache for Nix store paths. Instead of rebuilding packages, CI downloads pre-built binaries.

### Layered Cache Approach (rix Philosophy)

**From [rix documentation](https://cran.r-project.org/web/packages/rix/vignettes/z-binary_cache.html)**:

> "You can also use several caches at once, NixOS's public cache, our `rstats-on-nix` cache, and your own, so your cache will only end up holding the binaries not found in the other two caches!"

#### Cache Priority (When Pulling)

1. **cache.nixos.org** - NixOS public cache (system packages)
2. **rstats-on-nix.cachix.org** - R packages (CRAN, Bioconductor)
3. **johngavin.cachix.org** - Your project packages (randomwalk)

**Key insight**: Users only download from your cache what's NOT in upstream caches.

### Why Dependencies Get Pushed (And Why That's OK)

When you run `cachix push johngavin <package>`, Cachix pushes the **entire closure** (package + all dependencies). **This is expected and cannot be prevented.**

From [Bruno Rodrigues' blog](https://brodrigues.co/posts/2024-04-04-nix_for_r_part_11.html):
> "packages that are already available from the usual, public, cache.nixos.org don't get rebuilt nor cached in mine; they simply continue getting pulled directly from there."

**Implication**: Your cache contains duplicates (storage overhead), but users pulling still get dependencies from upstream (correct layered behavior).

### Automatic Garbage Collection

From [Cachix GC documentation](https://docs.cachix.org/garbage-collection):

- **Trigger**: At **85% of storage limit**
- **Algorithm**: Deletes oldest **unpinned** paths by last access date
- **Protection**: **Pinned** paths are immune to GC
- **No configuration needed**: Fully automatic

**Monitor**: https://app.cachix.org/garbage-collection

### Setup Steps

#### 1. Create Cachix Account

```bash
# Sign up at cachix.org
# Create cache named "johngavin" (or your username)
```

#### 2. Get Authentication Token

```bash
# Generate token in Cachix dashboard
# Or use CLI:
cachix authtoken
```

#### 3. Configure Locally

```bash
# Set up cachix locally
cachix use johngavin

# Test push
echo "test" | cachix push johngavin
```

#### 4. Add to GitHub Secrets

```
Repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions
‚Üí New repository secret
   Name: CACHIX_AUTH_TOKEN
   Value: <your token>
```

### Using Cachix (rix-Aligned Workflow)

**Push locally (before git push)**:
```bash
# From project directory
../push_to_cachix.sh

# This will:
# 1. Build package.nix
# 2. Push to cachix (dependencies included - expected!)
# 3. Pin package to protect from GC
```

**What gets pushed**:
- ‚úÖ Your package (randomwalk)
- ‚úÖ Dependencies (ggplot2, logger, crew, etc. - duplicates from rstats-on-nix)

**What gets used**:
- Users pulling get dependencies from rstats-on-nix (fast)
- Users only download randomwalk from johngavin (unique package)

**CI automatically**:
- Pulls from rstats-on-nix (R packages) ‚Üí fast, no rebuild
- Pulls from johngavin (your package, if cached) ‚Üí fast, no rebuild
- Pushes to johngavin if package was rebuilt

### Managing Cache Size

**Recommended**: Pin your packages, trust automatic GC

```bash
# Pin a specific version permanently
cachix pin johngavin randomwalk-v2.0.0 /nix/store/...-r-randomwalk --keep-forever

# Pin with time-based retention
cachix pin johngavin randomwalk-v2.0.0 /nix/store/...-r-randomwalk --keep-days 90
```

**Result**:
- Your packages: Protected from GC (pinned)
- Duplicate R packages: Automatically deleted when storage limit reached (unpinned)

**See**: `docs/CACHIX_WORKFLOW.md` for detailed cache management guide

---

## Troubleshooting

### Nix Files Out of Date

**Problem**: CI fails with "nix files out of date"

**Solution**:
```r
source("R/setup/generate_nix_files.R")
generate_all_nix_files()
gert::git_add(c("package.nix", "default-ci.nix"))
gert::git_commit("Update nix files")
```

### Cache Miss in CI

**Problem**: CI rebuilds package even though you pushed to cachix

**Cause**: Different code ‚Üí different hash

**Solution**:
1. Ensure you pushed code AFTER pushing to cachix
2. Check you pushed the right derivation:
   ```bash
   nix-build package.nix
   readlink -f result  # Should match CI store path
   ```

### Cachix Authentication Fails

**Problem**: `cachix push` fails with authentication error

**Solution**:
```bash
# Re-authenticate
cachix authtoken <YOUR_TOKEN>

# Verify
cat ~/.config/cachix/cachix.dhall
```

### Environment Degradation

**Problem**: Commands fail with "command not found" in long nix-shell sessions

**Solution**:
```bash
# Exit and re-enter
exit
nix-shell default.nix
```

### Package Build Fails in CI But Works Locally

**Problem**: `nix-build package.nix` works locally but fails in CI

**Common causes**:
1. **Uncommitted files**: CI doesn't see uncommitted changes
   ```bash
   git status  # Check for uncommitted files
   git add .   # Add them
   ```

2. **Different nixpkgs**: Local and CI using different revisions
   ```r
   # Check package.nix and default-ci.nix use same revision
   grep "nixpkgs/archive" package.nix default-ci.nix
   ```

3. **Missing dependencies**: Not declared in DESCRIPTION
   ```r
   # Add missing deps to DESCRIPTION
   usethis::use_package("missing_package")
   # Regenerate nix files
   update_nix_files()
   ```

---

## Quick Reference

### R Commands

```r
# Generate nix files
source("R/setup/generate_nix_files.R")
generate_all_nix_files()

# Update after DESCRIPTION changes
update_nix_files()

# Development workflow
devtools::load_all()
devtools::test()
devtools::check()

# Git/GitHub (using R packages)
usethis::pr_init("fix-issue-123")
gert::git_add("file.R")
gert::git_commit("message")
usethis::pr_push()
usethis::pr_merge_main()
```

### Bash Commands

```bash
# Enter nix environment
nix-shell default.nix

# Build package derivation
nix-build package.nix

# Push to cachix (MANDATORY before git push)
../push_to_cachix.sh

# Verify package structure
nix-build package.nix
ls -lh result/
```

### Files to Commit

Always commit these files:
- ‚úÖ `package.nix`
- ‚úÖ `default-ci.nix`
- ‚úÖ `default.nix` (symlink)
- ‚úÖ `.github/workflows/nix-ci.yml`
- ‚úÖ `R/setup/generate_nix_files.R`
- ‚úÖ `R/setup/*.R` (session logs)

Do NOT commit:
- ‚ùå `result` (symlink from nix-build)
- ‚ùå `result-*` (nix build outputs)
- ‚ùå `.nix-shell-*` (nix shell temp files)

### Cache Priority

```
rstats-on-nix (R packages) ‚Üí johngavin (your package) ‚Üí Build from source
```

### Workflow Summary

```
1. Create issue ‚Üí 2. Create branch ‚Üí 3. Make changes ‚Üí
4. Run checks ‚Üí 5. Push to cachix ‚Üí 6. Push to GitHub ‚Üí
7. Wait for CI ‚Üí 8. Merge PR ‚Üí 9. Log commands
```

---

## Known Limitations

### pkgdown with Quarto Vignettes

**Limitation**: `pkgdown::build_site()` **cannot work in Nix** when using Quarto vignettes with bslib styling.

**Why**:
1. Quarto vignettes require Bootstrap 5
2. Bootstrap 5 requires the `bslib` R package
3. bslib attempts to copy JS/CSS files from `/nix/store` (read-only) during runtime
4. Nix's immutable store model prevents this copy operation

**This is not a bug** - it's a fundamental design incompatibility between:
- Nix's immutability (packages can't modify themselves at runtime)
- bslib's behavior (copies assets from package installation to temp dirs)

**Solution**: Use **native R (r-lib/actions)** for pkgdown in GitHub Actions:

```yaml
# Don't use Nix for pkgdown workflow
- uses: r-lib/actions/setup-r@v2           # ‚Üê Native R
- uses: r-lib/actions/setup-r-dependencies@v2
```

**What Still Works in Nix**:
- ‚úÖ Package development (`devtools::load_all()`, `devtools::test()`)
- ‚úÖ R CMD check (`devtools::check()`)
- ‚úÖ Data pipelines (`targets::tar_make()`)
- ‚úÖ pkgdown reference docs (without vignettes)
- ‚úÖ Rmarkdown vignettes (pre-built)

**What Requires Native R**:
- ‚ùå pkgdown with Quarto vignettes
- ‚ùå Any tool requiring runtime file writes to package directories

**Workflow Recommendation**:

```bash
# Local development (Nix):
targets::tar_make()        # ‚úÖ Data pipeline
devtools::check()          # ‚úÖ Package check

# CI (native R for pkgdown):
# .github/workflows/r-cmd-check.yml  ‚Üí Use Nix
# .github/workflows/pkgdown.yml      ‚Üí Use r-lib/actions
```

**See Also**: [NIX_TROUBLESHOOTING.md ¬ß pkgdown with Quarto Vignettes](NIX_TROUBLESHOOTING.md#pkgdown-with-quarto-vignettes)

---

## Additional Resources

- [rix documentation](https://docs.ropensci.org/rix/)
- [rix GitHub](https://github.com/ropensci/rix)
- [rix vignettes](https://cran.r-project.org/web/packages/rix/index.html)
- [Nix manual](https://nixos.org/manual/nix/stable/)
- [Cachix docs](https://docs.cachix.org/)
- [rstats-on-nix cache](https://app.cachix.org/cache/rstats-on-nix)

---

## Summary

**The workflow ensures**:
1. ‚úÖ **Reproducibility**: Content-addressable hashing guarantees correctness
2. ‚úÖ **Consistency**: Same environment locally and in CI
3. ‚úÖ **Transparency**: All nix files generated from DESCRIPTION via R code
4. ‚úÖ **Efficiency**: Binary caches eliminate rebuilds
5. ‚úÖ **Simplicity**: Clear 9-step workflow, well-documented

**Key principle**: Let Nix handle version matching via hashing. You focus on writing code.

---

**Last updated**: December 2025
**Version**: 2.0 (9-step workflow with mandatory cachix push)

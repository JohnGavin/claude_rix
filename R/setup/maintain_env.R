# Helper function for formatting Nix lists, now globally available
nix_list <- function(pkgs) {
  if (length(pkgs) == 0) return("")
  paste(pkgs, collapse = "\n    ")
}

# Helper function to generate Nix expressions for Git packages from Remotes field
remotes_to_nix_pkgs <- function(remotes_list) {
  if (is.null(remotes_list) || length(remotes_list) == 0) return("")
  
  nix_expressions <- c()
  for (remote_full in remotes_list) {
    # Expected format: owner/repo or owner/repo@ref
    remote <- strsplit(remote_full, "@")[[1]][1] # Remove ref for now
    parts <- strsplit(remote, "/")[[1]]
    owner <- parts[1]
    repo <- parts[2]

    # Assuming these are R packages. The name in pkgs.rPackages should be the repo name.
    # This needs careful mapping if the R package name != repo name.
    # For now, assuming repo name is the R package name in Nixpkgs.
    nix_expressions <- c(nix_expressions, paste0("pkgs.rPackages.", repo))
  }
  return(paste(nix_expressions, collapse = "\n    "))
}

# R/setup/maintain_env.R
# This script reads DESCRIPTION, extracts dependencies, and generates packages.R and default.nix.

maintain_env <- function() {
  if (!requireNamespace("rix", quietly = TRUE)) {
    stop("rix package is not installed.")
  }
  library(rix)

  # 1. Read DESCRIPTION
  desc <- read.dcf("DESCRIPTION")
  
  get_packages <- function(field) {
    if (!(field %in% colnames(desc))) return(character(0))
    pkgs_str <- desc[1, field]
    if (is.na(pkgs_str)) return(character(0))
    pkgs <- strsplit(pkgs_str, ",")[[1]]
    pkgs <- trimws(pkgs)
    pkgs <- gsub("\\s*\\([^)]*\\)", "", pkgs)
    pkgs <- pkgs[pkgs != "R"]
    return(pkgs)
  }

  imports <- get_packages("Imports")
  suggests <- get_packages("Suggests")

  get_git_packages <- function() {
    if (!("Remotes" %in% colnames(desc))) return(NULL)
    remotes_str <- desc[1, "Remotes"]
    if (is.na(remotes_str)) return(NULL)
    
    remotes <- strsplit(remotes_str, ",")[[1]]
    remotes <- trimws(remotes)
    
    git_pkgs_list <- list()
    for (remote in remotes) {
      if (grepl("/", remote)) { # Assuming owner/repo format for GitHub
        parts <- strsplit(remote, "/")[[1]]
        owner <- parts[1]
        repo <- parts[2]
        # Remove any version specifiers
        repo <- gsub("@.*$", "", repo)
        
        # Use owner_repo as name to avoid potential conflicts if multiple packages from same owner
        git_pkgs_list[[paste0(owner, "_", repo)]] <- paste0(owner, "/", repo)
      } else {
        message(paste("Warning: Unrecognized remote format for:", remote))
      }
    }
    if(length(git_pkgs_list) == 0) return(NULL)
    return(git_pkgs_list)
  }
  
  git_pkgs_list <- get_git_packages()
  
  # Base dev tools that we always want in the shell
  dev_tools <- c("devtools", "usethis", "gert", "gh", "rix", "testthat", "roxygen2", "rcmdcheck")
  
  # Combine and dedup
  r_pkgs <- unique(c(imports, suggests, dev_tools))
  r_pkgs <- sort(r_pkgs)
  
  # 2. Write packages.R
  packages_r_content <- paste0(
    "# This file is automatically generated by R/setup/maintain_env.R\n",
    "# Do not edit this file directly.\n\n",
    "r_pkgs <- c(\
  \"", paste(r_pkgs, collapse = "\",\n  \""), "\"\n)"
  )
  writeLines(packages_r_content, "packages.R")
  message("Generated packages.R")

  # 3. Generate default.nix
  # We use the shell_hook to set up the environment, specifically handling the $HOME issue.
  # Using R raw string r"---" (...) "---" preserves $HOME as is.
  # rix will write this into the nix file. 
  # We must ensure we don't double escape.

  shell_hook <- paste(
    "mkdir -p $HOME/.config/positron",
    "mkdir -p $HOME/.R/library",
    "echo \"R_LIBS_USER=$HOME/.R/library\" >> $HOME/.Renviron",
    "",
    "# Optional: Setup Positron/RStudio wrapper if needed (simplified from existing default.nix)",
    "export R_MAKEVARS_USER=/dev/null",
    "unset CI",
    "printf \"Environment loaded.\\n\"",
    sep = "\n"
  )

  # System packages needed
  sys_pkgs <- c(
    "awscli2", "bc", "btop", "cacert", "clang", "curlMinimal", "direnv", "duckdb", 
    "gcc", "gh", "git", "glibcLocales", "gnupg", "htop", "jq", "less", 
    "nix", "nodejs", "pandoc", "quarto", "R", "tree", "which"
  )

  rix(
    r_ver = "4.4.2", # Use a fixed, recent R version
    r_pkgs = r_pkgs,
    system_pkgs = sys_pkgs,
    git_pkgs = git_pkgs_list,
    ide = "none", # Use 'none' to avoid rix injecting strict rstudio/code wrappers
    project_path = ".",
    overwrite = TRUE,
    shell_hook = shell_hook
  )
  
  message("Generated default.nix")

  # 4. Generate package.nix (for Nix derivation builds)
  pkg_name <- desc[1, "Package"]
  
  # imports go to propagatedBuildInputs
  # suggests (for building vignettes/tests) go to nativeBuildInputs

  # Get Remotes for package.nix specific handling
  remotes_str <- desc[1, "Remotes"]
  package_remotes <- NULL
  if (!is.na(remotes_str)) {
    package_remotes <- trimws(strsplit(remotes_str, ",")[[1]])
  }

  package_nix_remotes_expr <- remotes_to_nix_pkgs(package_remotes)

  # Combine regular R imports with the Git packages for propagatedBuildInputs
  all_propagated_build_inputs <- c(
    nix_list(imports),
    if(nzchar(package_nix_remotes_expr)) package_nix_remotes_expr else NULL
  )
  
  all_propagated_build_inputs_str <- paste(all_propagated_build_inputs, collapse = "\n    ")

  package_nix_content <- sprintf(
'{ pkgs ? import (fetchTarball "https://github.com/rstats-on-nix/nixpkgs/archive/2025-02-24.tar.gz") {} }:

pkgs.rPackages.buildRPackage {
  name = "%s";
  src = ./.;

  propagatedBuildInputs = with pkgs.rPackages; [
    %s
  ];

  nativeBuildInputs = with pkgs.rPackages; [
    %s
  ];
}
',
    pkg_name, 
    all_propagated_build_inputs_str,
    nix_list(suggests)
  )
  
  writeLines(package_nix_content, "package.nix")
  message("Generated package.nix")
}

if (!interactive()) {
  maintain_env()
}